* Personal Emacs Configuration üè°
This repository contains the setup for an Emacs configuration, tailored for my use. It has features well suited for:
- Rust
- Python
- Systems administration
- General editing

It works best on macOS and in a graphical frame. For the best experience, use Mitsuharu's Emacs macOS port, or a pureGTK build on Linux. Currently, it only works on Emacs versions newer than 28.

I created this rather than using an existing configuration because when something breaks, most configurations are so opaque that it's unclear what parts feed into each other. The goal of this configuration is that each part is obvious, separated, and transparent in what it's doing, so that you can figure it out and quickly fix it yourself rather than ~grep~-ping through a thousand different ~.el~ files to find the bug.  

The whole configuration lives in this file, so just scroll down!

** How to Install üíª
Firstly, make sure the following programs are installed:
- ~python3~, MUST be Python 3
- ~ripgrep~ (optional)
- ~git~ (used by ~magit~)
- ~gcc~ and ~cmake~, used for ~vterm~ (optional, just say ~n~ when asked on install)
- ~fish~, used to make completion files for ~eshell~ (optional)
- ~aspell~, used for enabling spellcheck in ~jinx~ (optional)
- Any specific language servers/packages needed by certain modes:
  - Shell: ~checkbashisms~ (optional)
  - LaTeX: ~texlab~ (or any other language server)
  - Common Lisp: ~sbcl~ (or any other implementation)
  - Markdown: ~markdown~
  - Rust: ~rust-analyzer~
  - Python: ~black~ and ~pyright~ (all the other ones don't work)
  - Go: ~gopls~
  - Java: ~maven~, ~jdtls~, ~openjvm~ (obviously)
  
Ideally in a future version of this configuration, it would prompt you to install these, but that's currently not the case. I'll fix that eventually.

~git clone~ this into ~~/.emacs.d~, then start Emacs. This will take a little time on initial startup, but after the first boot this process should become substantially faster. It works on *my* machine, but I make no guarantees that this will be the case on yours! 
** Things To Improve ü§î
- Update this to use the new features in Emacs 30
- Make sure that Emacs makes sure you have all the packages you need, and gracefully degrades on failure
- Add ensures by default rather than typing it manually
- Add ~puni~ rather than ~paredit~
** The Actual Configuration üìñ
*** Package Manager & Key Tools
The default ~package.el~ is disabled by ~early-init.el~. Good old ~package.el~ is still the way to go, because we like stability and all the other ones eat our computer for breakfast. But we still need to define our repos:
#+begin_src emacs-lisp
      (setq package-archives
	    '(("gnu" . "https://elpa.gnu.org/packages/")
	      ("melpa" . "https://melpa.org/packages/")
	      ("nongnu" . "https://elpa.nongnu.org/nongnu/")))

  (package-initialize) ;; not gonna need that
#+end_src
And then install ~diminish~ and ~vc-use-package~ since we'll call it a lot later:
#+begin_src emacs-lisp
  (use-package diminish
    :ensure t)

  (if (version< emacs-version "30")
      (unless (package-installed-p 'vc-use-package)
	(package-vc-install "https://github.com/slotThe/vc-use-package")))
#+end_src
*** Graphics Fixes
We didn't have the frame loaded and rendered in until this point, so we couldn't fix stuff that was really visually annoying. Now, we can.
#+begin_src emacs-lisp
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (pixel-scroll-mode)

  (setq use-file-dialog nil
	use-dialog-box nil
	inhibit-startup-screen t)

  (setopt line-number-mode t
	  column-number-mode t
	  x-underline-at-descent-line nil
	  switch-to-buffer-obey-display-actions t
	  show-trailing-whitespace nil
	  indicate-buffer-boundaries 'left)

  ; horizontal mouse scrolling
  (setopt mouse-wheel-tilt-scroll t
	  mouse-wheel-flip-direction t)

  ; line numbers in programming modes
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (setopt display-line-numbers-width 3)

  ; wrap text in visual modes
  (add-hook 'text-mode-hook 'visual-line-mode)
  ; hack to hide visual line mode
  ; we don't need to see it. we'll *know*.
  (use-package emacs
    :diminish visual-line-mode)

  ; modes where hl-line is enabled
  (let ((hl-line-hooks '(text-mode-hook prog-mode-hook)))
    (mapc (lambda (hook) (add-hook hook 'hl-line-mode)) hl-line-hooks))
#+end_src
*** Behavior Fixes
These need to go first because if something fails later I need these loaded. Absolutely vital that this works.
#+begin_src emacs-lisp
  ; genuinely baffling how this isn't the default
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  ;need for code snippets
  (require 'org-tempo)

  ; reread files from disk
  (setopt auto-revert-avoid-polling t)
  (setopt auto-revert-interval 5)
  (setopt auto-revert-check-vc-info t)
  (global-auto-revert-mode)

  ;; move through windows with Ctrl-<arrow keys>
  (windmove-default-keybindings 'control)

  ;; fix archaic defaults
  (setopt sentence-end-double-space nil)

  ;; make right-click do something sensible
  (when (display-graphic-p)
    (context-menu-mode))

  ;; don't litter file system with *~ backup files; put them all inside
  ;; ~/.emacs.d/backup or wherever
  (let ((auto-dir (expand-file-name "autosaves/" user-emacs-directory))
	(backup-dir (expand-file-name "backups/" user-emacs-directory)))
    (dolist (dir (list auto-dir backup-dir))
      (unless (file-exists-p dir) (make-directory dir t)))
    (setq backup-directory-alist `(("." . ,backup-dir))
	  auto-save-file-name-transforms `((".*" ,auto-dir t))
	  auto-save-list-file-prefix (concat auto-dir ".saves-")))

  ;; highlight urls
  ;; if we don't set it this way, xwidget breaks
  (goto-address-prog-mode)

  ;; show the fill column
  (setq-default display-fill-column-indicator-column 80)
  (add-hook 'prog-mode-hook #'display-fill-column-indicator-mode)

  ;; force compliation to look nicer
  (add-hook 'complilation-mode-hook 'visual-line-mode)

  ;; nicer prompts
  (fset 'yes-or-no-p 'y-or-n-p)
  ;; doesn't work in older emacs
  (when (version< emacs-version "29")
    (when (boundp 'use-short-answers)
      (setopt use-short-answers t)))

  ;; remember where we are and what we're doing
  (save-place-mode 1)
  (setq history-length 1000
	recentf-max-saved-items 1000)
  (recentf-mode 1)
  (savehist-mode 1)

  ;; desktop mode for saving sessions
  (setq desktop-dirname             "~/.emacs.d/desktop"
	desktop-base-file-name      "session.el"
	desktop-base-lock-name      "session.lock"
	desktop-path                (list desktop-dirname)
	desktop-save                t
	desktop-load-locked-desktop nil
	desktop-restore-eager 20
	desktop-restore-frames t
	desktop-auto-save-timeout 30)
  (setq desktop-files-not-to-save "^$") ;; don‚Äôt skip tramp etc
  (make-directory desktop-dirname t)
  (desktop-save-mode 1)
  (when (file-exists-p (desktop-full-file-name))
    (desktop-read))
  (add-hook 'kill-emacs-hook #'(lambda () (desktop-save-in-desktop-dir)))

  ;; always use UTF-8
  (prefer-coding-system 'utf-8)
  (setq locale-coding-system 'utf-8)
  (unless *is-a-windows*
    (set-selection-coding-system 'utf-8))

  ;; when we have two unique buffers, act like it
  (require 'uniquify)
  (setq uniquify-separator " ‚Ä¢ "
	uniquify-after-kill-buffer-p t
	uniquify-ignore-buffers-re "^\\*"
	uniquify-buffer-name-style 'reverse)

  ;; handle long files
  (when (fboundp 'so-long-enable)
    (add-hook 'after-init-hook 'so-long-enable))

  ;; when we're a mac, use mdfind not find
  (when *is-a-mac*
    (setq-default locate-command "mdfind"))

  ;; make TRAMP faster
  (use-package tramp
    :config
    (connection-local-set-profile-variables
     'remote-direct-async-process
     '((tramp-direct-async-process . t)))
    (connection-local-set-profiles
     '(:application tramp :protocol "ssh")
     'remote-direct-async-process)
    ;; Tips to speed up connections
    (setq tramp-verbose 10)
    (setq tramp-chunksize 2000)
    (setq tramp-ssh-controlmaster-options nil))


  ;; fix the ls related issues on macOS & Unix
  (if (or *is-a-mac* *is-a-haiku* *is-a-unix*)
      (progn
	(setq ls-lisp-use-insert-directory-program nil
	      dired-use-ls-dired nil)
	(require 'ls-lisp)))
#+end_src
*** Utility Functions
These are things that I use that are nice to have but aren't part of GNU Emacs. Although many of them are basically replaced by ~crux~ at this point, it's nice to keep around a vanilla implementation in case packages can't be installed.
#+begin_src emacs-lisp
  ;; redefine the annoying GNU advertisement
    (defun display-startup-echo-area-message ()
      "Gets rid of that annoying GNU advertisement."
      (message "[init.el] Init complete. Get out there!"))

  ;; kill the buffer and file
  (defun personal/delete-this-file-and-buffer ()
    "Delete the current file and kill its buffer."
    (interactive)
    (unless (buffer-file-name)
      (error "Nothing is being edited right now!"))
    (when (y-or-n-p (format "Really delete '%s'? "
			    (file-name-nondirectory buffer-file-name)))
      (delete-file (buffer-file-name))
      (kill-this-buffer)
      (message "Buffer killed.")))

  ;; Rename the buffer and file
  (defun personal/rename-this-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive "sNew name: ")
    (let ((name (buffer-name))
	  (filename (buffer-file-name)))
      (unless filename
	(error "Buffer '%s' is not visiting a file!" name))
      (progn
	(when (file-exists-p filename)
	  (rename-file filename new-name 1))
	(set-visited-file-name new-name)
	(rename-buffer new-name)
	(message "Buffer renamed."))))

  ;; Simpify our life.
  (defun personal/revert-to-two-windows ()
    "Delete all other windows and split it into two."
    (interactive)
    (delete-other-windows)
    (split-window-right))

  ;; deal with adding extensions for a mode.
  (defun add-auto-mode (mode &rest patterns)
    "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
    (dolist (pattern patterns)
      (add-to-list 'auto-mode-alist (cons pattern mode))))

  ;; stops flycheck from yelling at you
  (defun personal/headerise-elisp ()
    "Add minimal header and footer to an elisp buffer in order to placate flycheck."
    (interactive)
    (let ((fname (if (buffer-file-name)
		     (file-name-nondirectory (buffer-file-name))
		   (error "This buffer is not visiting a file"))))
      (save-excursion
	(goto-char (point-min))
	(insert ";;; " fname " --- Insert description here -*- lexical-binding: t -*-\n"
		";;; Commentary:\n"
		";;; Code:\n\n")
	(goto-char (point-max))
	(insert ";;; " fname " ends here\n"))))

  ;; kill all buffers instantly
  ;; genuinely WHY is this not already built-in
  (defun personal/close-all-buffers ()
    "Kill all buffers without regard for their origin."
    (interactive)
    (mapc 'kill-buffer (buffer-list)))
  (global-set-key (kbd "C-M-s-k") 'close-all-buffers)

  ;; quickly visit our configuration
  (defun personal/config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
#+end_src
*** Packages: Utility
This category is for packages which extend Emacs without adding brand new features. Basically just overhauls of existing features.
**** ~osx-trash~
Really nice fix for the fact that stock Emacs can't do this.
#+begin_src emacs-lisp
  (use-package osx-trash
    :ensure t
    :if *is-a-mac*
    :init
    (if (executable-find "trash")
      (setq osx-trash-command "trash"))
    (osx-trash-setup))
  (setopt delete-by-moving-to-trash t)
#+end_src
**** ~which-key~
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :diminish
    :config
    (which-key-mode))
#+end_src
**** ~sudo-edit~ & ~auto-sudoedit~
We want to be able to edit as root, but only on Unix and Linux.
#+begin_src emacs-lisp
  (use-package sudo-edit
    :if (or *is-a-linux* *is-a-unix*)
    :ensure t)
#+end_src
Also, automatically retry if we can't do it for whatever reason.
#+begin_src emacs-lisp
  (use-package auto-sudoedit
    :ensure t
    :diminish
    :init
    (require 'auto-sudoedit)
    (auto-sudoedit-mode 1))
#+end_src
**** ~exec-path-from-shell~
We run it as non-interactive because Anaconda, if we have it installed, will slow down Emacs.
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :config
    (setq exec-path-from-shell-arguments nil)
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+end_src
**** ~async~
#+begin_src emacs-lisp
  (use-package async
    :ensure t
    :config
    (async-bytecomp-package-mode 1)
    (dired-async-mode 1))
#+end_src
**** ~editorconfig~
#+begin_src emacs-lisp
  (use-package editorconfig
    :ensure t
    :diminish
    :config
    (editorconfig-mode 1))
#+end_src
**** ~whole-line-or-region~
This is extremely useful since we often want to run a command on the line, but don't want to bother with painstakingly selecting the right region
#+begin_src emacs-lisp
  (use-package whole-line-or-region
    :ensure t
    :diminish whole-line-or-region-local-mode
    :hook (after-init . whole-line-or-region-global-mode))
#+end_src
**** ~wgrep~
This package lets us mass edit search results, which is amazing!
#+begin_src emacs-lisp
  (use-package wgrep
    :ensure t
    :config
    (setq wgrep-auto-save-buffer t))
#+end_src
**** ~prism~
This color-codes the syntax of code so that it's color coded by syntax level. Like a superpowered version of syntax highlighting.
#+begin_src emacs-lisp
  (use-package prism
    :ensure t
    :vc (prism :url "https://github.com/alphapapa/prism.el"
		 :branch "master"))
#+end_src
**** ~anzu~
Displays the amount of matches for any given search, which is quite useful.
#+begin_src emacs-lisp
  (use-package anzu
    :ensure t
    :diminish 
    :init
    (global-anzu-mode +1))
#+end_src
**** ~scratch~
It's often useful to pop open a scratch buffer for a given mode without making a file. So useful that we need a hotkey for it.
#+begin_src emacs-lisp
  (use-package scratch
    :ensure t
    :bind ("C-c s" . scratch))
#+end_src
**** ~switch-window~
Extremely useful when you've got a lot of these on the screen.
#+begin_src emacs-lisp
  (use-package switch-window
    :ensure t
    :config
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-timeout nil)
    :bind
    ("C-x o". switch-window))
#+end_src
**** ~other-frame-window~
Emacs has an /okay/ window manager, but it's preferable to use the real OS one. So to fix this, we can use this package, so that we can spawn buffers in other windows. The one caveat is that if you make too many windows, it can become dangerous, as you could accidentally delete your primary Emacs window. Use with care.
#+begin_src emacs-lisp
  (use-package other-frame-window
    :ensure t
    :diminish
    :init
    (other-frame-window-mode))
#+end_src
**** ~osx-clipboard-mode~
Allows the use of the macOS clipboard, even if we're not on the terminal
#+begin_src emacs-lisp
  (use-package osx-clipboard
    :if (and (not (window-system)) *is-a-mac*)
    :ensure t
    :diminish
    :init
    (osx-clipboard-mode +1))
#+end_src
**** ~restart-emacs~
Restart Emacs from within Emacs! Useful for config updates.
#+begin_src emacs-lisp
  (use-package restart-emacs
    :ensure t)
#+end_src
**** ~edit-indirect~
Allows for editing a part of a buffer in another buffer.
#+begin_src emacs-lisp
  (use-package edit-indirect
    :ensure t)
#+end_src
**** ~quickrun~
The equivalent of clicking the big "Run" button in an IDE. Basically compiles and executes the buffer.
#+begin_src emacs-lisp
  (use-package quickrun
    :ensure t)
#+end_src
**** ~makefile-executor~
Allows us to execute certain targets at any buffer in a project.
#+begin_src emacs-lisp
  (use-package makefile-executor
    :ensure t
    :config
    (add-hook 'makefile-mode-hook 'makefile-executor-mode))
#+end_src
**** ~lorem-ipsum~
Quick filler text, if needed.
#+begin_src emacs-lisp
  (use-package lorem-ipsum
    :ensure t)
#+end_src
**** ~crux~
A bunch of extremely useful functions indeed! It adds all the things that the Emacs devs seemingly forgot to put into the final version.
#+begin_src emacs-lisp
  (use-package crux
    :ensure t)
#+end_src
**** ~insert-kaomoji~
Incredibly useful package.
#+begin_src emacs-lisp
  (use-package insert-kaomoji
    :ensure t)
#+end_src
**** ~insert-random~
Maybe useful under a particularly strange set of circumstances?
#+begin_src emacs-lisp
  (use-package insert-random
    :ensure t)
#+end_src
**** ~evil-nerd-commenter~
Despite the name, it's not really required to use ~evil~ for it. What it actually does is quickly uncomments or comments out a line. It's a bit smarter than the default one because it works on multiple lines if you combine it with ~C-u~.
#+begin_src emacs-lisp
  (use-package evil-nerd-commenter
    :ensure t
    :bind ("M-;" . evilnc-comment-or-uncomment-lines))
#+end_src
**** ~visual-replace~
Shows the replacements that we're going to do. It shows what the buffer will look like after the replacement.
#+begin_src emacs-lisp
  (use-package visual-replace
    :ensure t
    :diminish
    :init
    (visual-replace-global-mode 1))
#+end_src
**** ~decide~
TODO: this package is terrible. Write your own...?
#+begin_src emacs-lisp
  (use-package decide
    :ensure t)
#+end_src
*** Packages: Appearance
This category is for packages which make Emacs' interface look nicer.
**** Themes: ~solarized~, ~vscode-dark-plus~, ~waher~, ~modus~
I quite like the dark VSCode and Solarized themes, but ~modus~ is winning me over at present. All are installed, so it's easy to change them. At present, the theme system also can intelligent switch between night and day mode. Nice!
#+begin_src emacs-lisp
  ; ignore asking if custom themes are safe
  (setq custom-safe-themes t)

  (use-package solarized-theme
    :ensure t
    :demand t
    :config
    (setq solarized-high-contrast-mode-line nil
	  solarized-distinct-doc-face t
	  solarized-distinct-fringe-background t
	  solarized-emphasize-indicators t
	  x-underline-at-descent-line t))
    ;(load-theme 'solarized-selenized-black t)

  (use-package vscode-dark-plus-theme
    :ensure t
    :demand t)
    ;;:init
    ;;(load-theme 'vscode-dark-plus t))

  (use-package night-owl-theme
    :ensure t
    :demand t)

  (use-package waher-theme
    :ensure t
    :demand t
    :init)
  ;;(load-theme 'waher t))

  (use-package modus-themes
    :ensure t
    :demand t)
#+end_src
And then, of course, ~auto-dark-mode~:
#+begin_src emacs-lisp
  (use-package auto-dark
    :ensure t
    :custom
    (auto-dark-themes '((modus-vivendi-tritanopia) (modus-operandi)))
    (auto-dark-polling-interval-seconds 5)
    (auto-dark-allow-osascript t)
    :hook
    (auto-dark-dark-mode
     . (lambda ()
	 (message "[auto-dark] Dark mode theme automatically applied")))
    (auto-dark-light-mode
     . (lambda ()
	 (message "[auto-dark] Light mode theme automatically applied")))
    :init (auto-dark-mode))
#+end_src
**** Modeline: ~telephone-line~
It's a bit nicer looking than the powerbars, which are too flashy for me.
#+begin_src emacs-lisp
  (use-package telephone-line
    :ensure t
    :demand t
    :if window-system
    :diminish telephone-line-mode
    :config
    (setq telephone-line-lhs
	  '((evil   . (telephone-line-flycheck-segment))
	    (accent . (telephone-line-vc-segment
		       telephone-line-process-segment))
	    (nil    . (telephone-line-projectile-segment
		       telephone-line-buffer-segment)))
	  telephone-line-rhs
	  '((nil    . (telephone-line-position-segment))
	    (accent . (telephone-line-major-mode-segment))
	    ;; I used to put minor mode here but it's way too annoying in practice.
	    ;; This is where our LSP info will live
	    (evil   . (telephone-line-misc-info-segment)))
	  telephone-line-height 24
	  ;; different layouts don't render well on macOS.
	  telephone-line-primary-left-separator 'telephone-line-nil
	  telephone-line-secondary-left-separator 'telephone-line-nil
	  telephone-line-primary-right-separator 'telephone-line-nil
	  telephone-line-secondary-right-separator 'telephone-line-nil)
    (telephone-line-mode 1))
#+end_src
**** ~solaire~
Makes the buffers that aren't part of real files a different color than those that are.
#+begin_src emacs-lisp
  (use-package solaire-mode
    :ensure t
    :config
    (solaire-global-mode +1))
#+end_src
**** ~smooth-scrolling~
This is the best package at least on macOS, and probably the best on Linux too.
#+begin_src emacs-lisp
  (use-package smooth-scrolling
    :ensure t
    :diminish
    :hook (after-init . (lambda ()
			  (smooth-scrolling-mode 1))))
#+end_src
**** ~dimmer~
This package appears to be bugged. I'll have it be turned off for now
#+begin_src emacs-lisp
  (use-package dimmer
    :disabled t
    :if window-system
    :diminish
    :config
    (setq dimmer-adjustment-mode :background
	  dimmer-fraction 0.1
	  dimmer-use-colorspace :rgb)
    (require 'dimmer)
    (dimmer-configure-which-key)
    (dimmer-configure-helm)
    (dimmer-mode t))
#+end_src
**** ~beacon~
#+begin_src emacs-lisp
  (use-package beacon
    :ensure t
    :diminish
    :config
    (beacon-mode 1))
#+end_src
**** ~huecycle~
Makes certain parts of the screen change color when idle. A nicer alternative to ~zone~.
#+begin_src emacs-lisp
  ;; TODO: doesn't actually work, package is bugged
  (use-package huecycle
    :ensure t
    :config
    (huecycle-set-faces
     ((background . (hl-line))
      :random-color-hue-range (0.0 1.0)
      :random-color-saturation-range (0.8 1.0)
      :random-color-luminance-range (0.8 0.9))
      :speed 3.0)
    (huecycle-when-idle 5))
#+end_src
**** ~goggles~
#+begin_src emacs-lisp
  ;; flash the text that we're looking at when editing
  (use-package goggles
    :ensure t
    :diminish
    :hook ((prog-mode text-mode) . goggles-mode)
    :config
    (setq-default goggles-pulse t))
#+end_src
**** ~indent-bars~
Highlight the code level we're at.
#+begin_src emacs-lisp
  (use-package indent-bars
    :ensure t
    :diminish
    :hook (prog-mode . indent-bars-mode))
#+end_src
**** ~highlight-escape-sequences~
#+begin_src emacs-lisp
  (use-package highlight-escape-sequences
    :ensure t
    :diminish hes-mode
    :hook (after-init . hes-mode))
#+end_src
**** ~highlight-numbers~
This package highlights numerical literals, not just any random number
#+begin_src emacs-lisp
  (use-package highlight-numbers
    :ensure t
    :diminish
    :hook (prog-mode . highlight-numbers-mode))
#+end_src
**** ~page-break-lines~
Shows us when the page break character is there in our text.
#+begin_src emacs-lisp
  (use-package page-break-lines
    :ensure t
    :diminish
    :hook (after-init . global-page-break-lines-mode))
#+end_src
**** ~rainbow-delimiters~
This only applies to parenthesis, but it makes Lisp a lot easier to read!
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :diminish rainbow-delimiters-mode
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
**** ~rainbow-mode~
Make hex color codes match their values.
#+begin_src emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :diminish
    :hook ((emacs-lisp-mode . rainbow-mode)
	   (help-mode . rainbow-mode)
	   ((css-mode html-mode sass-mode) . rainbow-mode)))
#+end_src
**** ~cowsay~
Add a little fortune to our scratch buffers.
#+begin_src emacs-lisp
  ;; make the image
  (use-package cowsay
    :ensure t
    :init
    (cowsay-load-cow-file (expand-file-name "tux.cow" user-emacs-directory)))

  ;; wrap the cow in comments
  (defun personal/prefix-comment (arg)
    "Comment ARG with semicolons."
    (interactive)
    (mapconcat
     (lambda (x) (concat ";; " x))
     (split-string arg "\n" t) "\n"))

  ;; now actually set our scratch buffer
  (setq inhibit-startup-message t
	initial-scratch-message (concat (personal/prefix-comment  (cowsay-string "Emacs has finished starting." "tux")) "\n\n"))
#+end_src
**** ~org-superstar-mode~
Makes ~org-mode~ have some prettier-looking bullet points!
#+begin_src emacs-lisp
  (use-package org-superstar
    :ensure t
    :diminish
    :config
    (add-hook 'org-mode-hook (lambda () (org-superstar-mode 1))))
#+end_src
**** ~dired-fl~
This adds some special fonts to the ~dired~ mode to make it nicer.
#+begin_src emacs-lisp
  (use-package diredfl
    :ensure t
    :diminish
    :init
    (diredfl-global-mode))
#+end_src
**** ~pangu-spacing~
Improves aesthetics of having Japanese characters and English ones side by side. Áæé„Åó„ÅÑÊó•Êú¨Ë™ûÂÖ•Âäõ!
#+begin_src emacs-lisp
  (use-package pangu-spacing
    :ensure t
    :diminish
    :init
    (global-pangu-spacing-mode 1))
#+end_src
**** ~kind-icon~
Despite the name we never actually use any icons, at least not on the terminal. This just adds a little symbol to ~corfu~ that shows you what exactly you're completing.
#+begin_src emacs-lisp
  (use-package kind-icon
    :ensure t
    :after corfu
    :custom
    (kind-icon-use-icons nil)
    ; (kind-icon-default-face 'corfu-default) ; only needed with blend-background
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src
**** ~fancy-compile~
Running the ~compile~ command now does more useful things with better syntax highlighting.
#+begin_src emacs-lisp
  (use-package fancy-compilation
    :ensure t
    :diminish
    :init
    (fancy-compilation-mode))
#+end_src
**** ~olivetti~
This package allows you to turn on edges to your buffer, kind of like in Microsoft Word with its page limit. This way, no matter how big your frame is, your buffer still kinda looks nice. Which is a cool feature to have for editing text documents, so that text isn't strewn across the whole page.
#+begin_src emacs-lisp
  (use-package olivetti
    :ensure t)
#+end_src
**** ~pretty-sha-path~
Tidy up GUIX/Nix directories when you see them in Emacs.
#+begin_src emacs-lisp
  (use-package pretty-sha-path
    :ensure t
    :diminish
    :init
    (global-pretty-sha-path-mode))
#+end_src
*** Packages: Overhauls
Some parts of Emacs are fundamentally broken. These packages replace those features outright with new things. I note what's being replaced.
**** ~eat~: Replacement of ~ansi-term~
Fine on every OS but is a bit slower than ~vterm~.
#+begin_src emacs-lisp
  (use-package eat
    :ensure t
    :custom
    (eat-term-name "xterm")
    :init
    (add-hook 'eshell-load-hook #'eat-eshell-mode)
    (add-hook 'eshell-load-hook #'eat-eshell-visual-command-mode))
#+end_src
**** ~vterm~: Another Replacement of ~ansi-term~
Faster but requires the compiled module so this can fail quite dramatically. It doesn't match theme colors, because the colors you want for editing code vs running commands should be different.
#+begin_src emacs-lisp
  (use-package vterm
    :ensure t
    :if (not *is-a-windows*)
    :init
    ;; use classic terminal colors
    ;; also, this gives us a dark mode terminal all the time
    (setq vterm-color-black   "#000000"
	vterm-color-white   "#ffffff"
	vterm-color-red     "#ff5c57"
	vterm-color-green   "#5af78e"
	vterm-color-yellow  "#f3f99d"
	vterm-color-blue    "#57c7ff"
	vterm-color-magenta "#ff6ac1"
	vterm-color-cyan    "#9aedfe"))
#+end_src
**** ~multi-term~ & ~multi-vterm~: Summon Many Terminals
We often need more than one terminal when we're doing things. Let's add that:
#+begin_src emacs-lisp
  (use-package multi-term
    :ensure t)
#+end_src
Oh, and add that for ~vterm~, too:
#+begin_src emacs-lisp
  (use-package multi-vterm
    :ensure t)
#+end_src
This is such a good feature that stock ~vterm~ should never be used, only ~multi-vterm~.
**** ~jinx~: Replacement of ~flyspell~
Flyspell is the worst. This is a much better alternative with almost no downsides. We'll also fix our dictionary while we're at it.
#+begin_src emacs-lisp
  (use-package jinx
    :ensure t
    :hook (((text-mode prog-mode) . jinx-mode))
    :bind (("C-;" . jinx-correct))
    :custom
    (jinx-camel-modes '(prog-mode))
    (jinx-delay 0.01))

  (setopt dictionary-use-single-buffer t
	  dictionary-server "dict.org")
#+end_src
**** A Bunch of ~eshell~ Fixes
There's not really one big package that fixes ~eshell~, but a lot of these get really close to a full overhaul.

Here's one that lets us see command feedback, like in ~zsh~:
#+begin_src emacs-lisp
  (use-package eshell-fringe-status
    :ensure t
    :after eshell
    :diminish eshell-fringe-status-mode
    :hook (eshell-mode . eshell-fringe-status-mode))
#+end_src
And we probably want some better suggestion feedback:
#+begin_src emacs-lisp
  (use-package eshell-did-you-mean
    :ensure t
    ; doesn't work on Windows
    :if (or *is-a-linux* *is-a-mac*)
    :after eshell
    :config
    (eshell-did-you-mean-setup))

  (use-package esh-autosuggest
    :ensure t
    :after eshell
    :diminish eshell-autosuggest-mode
    :hook (eshell-mode . esh-autosuggest-mode))
#+end_src
We can also use ~fish~ scripts in ~eshell~, if it's installed:
#+begin_src emacs-lisp
  (use-package fish-completion
    :ensure t
    :after eshell
    :diminish global-fish-completion-mode
    :if (and (executable-find "fish") (or *is-a-linux* *is-a-mac*))
    :config
    (global-fish-completion-mode))
#+end_src
Lastly, syntax highlighting:
#+begin_src emacs-lisp
  (use-package eshell-syntax-highlighting
    :ensure t
    :diminish eshell-syntax-highlighting-global-mode
    :after eshell
    :config
    (eshell-syntax-highlighting-global-mode +1))
#+end_src
**** ~consult~: Command Enhancements
These commands completely replace their stock components with upgrades. ~M-y~ to open the kill ring is amazing, genuinely. Makes it about 100x more usable.
#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    :bind (
	   ;; Drop-in replacements
	   ("C-x b" . consult-buffer)     ; orig. switch-to-buffer
	   ("M-y"   . consult-yank-from-kill-ring)   ; orig. yank-pop
	   ;; Searching
	   ("M-s r" . consult-ripgrep)
	   ("M-s l" . consult-line)       ; Alternative: rebind C-s to use
	   ("M-s s" . consult-line)       ; consult-line instead of isearch, bind
	   ("M-s L" . consult-line-multi) ; isearch to M-s s
	   ("M-s o" . consult-outline)
	   ;; Isearch integration
	   :map isearch-mode-map
	   ("M-e" . consult-isearch-history)   ; orig. isearch-edit-string
	   ("M-s e" . consult-isearch-history) ; orig. isearch-edit-string
	   ("M-s l" . consult-line)            ; needed by consult-line to detect isearch
	   ("M-s L" . consult-line-multi)      ; needed by consult-line to detect isearch
	   )
    :config
    ;; Narrowing lets you restrict results to certain groups of candidates
    (setq consult-narrow-key "<"))
#+end_src
**** ~vertico~: Better Vertical Completion
Basically exactly what it says. Makes every menu better.
#+begin_src emacs-lisp  
  (use-package vertico
    :ensure t
    :init
    (vertico-mode))

  (use-package vertico-directory
    :ensure nil
    :after vertico
    :bind (:map vertico-map
		("M-DEL" . vertico-directory-delete-word)))
#+end_src
**** ~marginalia~: Annotations with Completions
Helps you figure out what exactly that option does.
#+begin_src emacs-lisp
  (use-package marginalia
    :ensure t
    :config
    (marginalia-mode))
#+end_src
**** ~orderless~: Global Fuzzy Find
This is a magical package that allows for any matching string to work in a search.
#+begin_src emacs-lisp
  (use-package orderless
    :ensure t
    :config
    (setq completion-styles '(orderless)))
#+end_src
**** ~corfu~: In-Buffer Completion
This is popup completion, which is a feature GNU Emacs has but doesn't use well.
It's a good replacement for ~company~.
#+begin_src emacs-lisp
  (use-package corfu
    :ensure t
    :diminish corfu-mode corfu-popupinfo-mode
    :init
    (global-corfu-mode)
    (corfu-history-mode)
    (corfu-popupinfo-mode)
    :bind (:map corfu-map ("RET" . nil))
    ;; if we use eshell, be careful not to autocomplete
    :hook (eshell-mode-hook . (lambda ()
				(setq-local corfu-auto nil)
				(corfu-mode)))
    :config
    ;; use corfu in the minibuffer
    (defun corfu-enable-always-in-minibuffer ()
      (unless (or (bound-and-true-p mct--active)
		    (bound-and-true-p vertico--input))
      (setq-local corfu-auto nil)
      (corfu-mode 1)))
    (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer 1)
    ;; automatic completion!
    (setq corfu-auto t
	  ;; I don't care what the warnings say, this setting rules
	  corfu-auto-prefix 2
	  corfu-quit-no-match 'separator
	  corfu-echo-documentation nil)
    ;; turn on corfu's plugins
    (corfu-history-mode 1))
#+end_src
We also want some popups and to have it work in the terminal:
TODO: this is fixed in Emacs 31.
#+begin_src emacs-lisp
  (use-package corfu-terminal
    :if (not (display-graphic-p))
    :ensure t
    :diminish
    :config
    (corfu-terminal-mode))
#+end_src
**** ~cape~: More Completions For ~corfu~
~corfu~ ships with a lot of built in configurations but it's still missing a lot of the functionality that ~company~ ships with. This package adds that back in so that it works properly. I don't want to trigger these manually, so I handle them all through ~corfu~.
#+begin_src emacs-lisp
  (use-package cape
    :ensure t
    :init
    (add-hook 'completion-at-point-functions #'cape-dabbrev)
    (add-hook 'completion-at-point-functions #'cape-file)
    (add-hook 'completion-at-point-functions #'cape-history))
#+end_src
**** ~helpful~: Help System
#+begin_src emacs-lisp
  (use-package helpful
    :ensure t
    :config
    (global-set-key (kbd "C-h f") #'helpful-callable)
    (global-set-key (kbd "C-h v") #'helpful-variable)
    (global-set-key (kbd "C-h k") #'helpful-key)
    (global-set-key (kbd "C-h x") #'helpful-command)
    ;; this might break some lisp modes
    (global-set-key (kbd "C-c C-d") #'helpful-at-point)
    ;; this overrides GNU Info
    (global-set-key (kbd "C-h F") #'helpful-function))
#+end_src
**** ~ctrlf~: Better ~isearch~
This replaces ~isearch~ but is genuinely an improvement in every way.
#+begin_src emacs-lisp
  (use-package ctrlf
    :ensure t
    :diminish
    :init
    (ctrlf-mode +1))
#+end_src
**** ~mwim~: Better ~C-e~ and ~C-a~
Moves to the next logical line position, not just to the end of the line.
#+begin_src emacs-lisp
  (use-package mwim
    :ensure t
    :diminish
    :config
    (global-set-key (kbd "C-a") 'mwim-beginning)
    (global-set-key (kbd "C-e") 'mwim-end))
#+end_src
**** ~pdf-tools~: Replacement of ~docview~
The existing document viewer is terrible. This is a bit better, but it does require being compiled, so it will almost certainly break on Windows.
#+begin_src emacs-lisp
  (use-package pdf-tools
    :ensure t
    :init
    (pdf-loader-install)
    (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-view-mode)
    (setq-default pdf-view-display-size 'fit-page)))
#+end_src
We should also remember our position within those documents:
#+begin_src emacs-lisp
  (use-package pdf-view-restore
    :ensure t
    :after pdf-tools
    :diminish
    :init
    (setq pdf-view-restore-filename "~/.emacs.d/pdf-view-restore")
    (add-hook 'pdf-view-mode-hook 'pdf-view-restore-mode))
#+end_src
**** ~visual-regexp~: Replacement of ~regexp~
Why use Emacs's ancient regexp format when we can use the much better ones that come with Python? We'll replace only the stuff we're not replacing elsewhere.
#+begin_src emacs-lisp
  (use-package visual-regexp-steroids
    :ensure t
    :if (executable-find "python3")
    :init
    (require 'visual-regexp-steroids))
#+end_src
**** ~undo-fu~: Better Undo
Emacs undo can be confusing and it also doesn't persist for all of time, which is an amazing thing to have. Let's add that.
#+begin_src emacs-lisp
  (use-package undo-fu
    :ensure t
    :config
    (global-unset-key (kbd "C-z"))
    (global-set-key (kbd "C-z")   'undo-fu-only-undo)
    (global-set-key (kbd "C-S-z") 'undo-fu-only-redo)
    :init
    ;; we have like so much ram nowadays
    (setq undo-limit 67108864)
    (setq undo-strong-limit 100663296)
    (setq undo-outer-limit 1006632960))

  (use-package undo-fu-session
    :ensure t
    :diminish
    :init
    (undo-fu-session-global-mode))
#+end_src
**** ~vundo~: Undo in a Tree
It's hard to mentally picture all the undos, but since we already have infinity undo state, it might be nice to do that
#+begin_src emacs-lisp
  (use-package vundo
    :ensure t
    :init
    (setq diff-switches "-u --color=never")
    (setq vundo-glyph-alist vundo-unicode-symbols))
#+end_src
**** ~yasnippet~: Dynamic templates, replace the macro system
TODO: remove or rework this, I never use it
This saves typing a lot of the same things over and over again by automatically completing them. This is really useful in more verbose languages.
#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :disabled t
    :diminish yas-mode
    :config
    (yas-global-mode 1))

  ;; the actual snippets
  (use-package yasnippet-snippets
    :ensure t
    :disabled t
    :after yasnippet)
#+end_src
What's really nice is that we don't even really need to know them. We can just magically filter through them with some good old fashioned ~completion-at-point~ magic:
#+begin_src emacs-lisp
  (use-package yasnippet-capf
    :ensure t
    :disabled t
    :after cape
    :config
    (add-to-list 'completion-at-point-functions #'yasnippet-capf))
#+end_src
**** ~tree-sitter~: Every Major Mode
This is technically in Emacs now, but the version it ships with can sometimes be woefully out of date.
#+begin_src emacs-lisp
  (use-package tree-sitter
    :ensure t
    :diminish
    :init
    (global-tree-sitter-mode)
    (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))

  (use-package tree-sitter-langs
    :ensure t
    :after tree-sitter)
#+end_src
And, when we can, we can try to switch to an upgraded mode:
#+begin_src emacs-lisp
  (use-package treesit-auto
    :ensure t
    :custom
    (treesit-auto-install 'prompt)
    :config
    (treesit-auto-add-to-auto-mode-alist 'all)
    (global-treesit-auto-mode))
#+end_src
**** ~disproject~: Transient ~project.el~
Transient interfaces are great! They are amazing to use in ~magit~, this brings them into ~project~ so that I actually remember to use it.
#+begin_src emacs-lisp
  (use-package disproject
    :ensure t
    :bind (:map ctl-x-map
	    ("p" . disproject-dispatch)))
#+end_src
*** Packages: Additions
These packages add brand-new features and modes to Emacs.
**** ~magit~: A Git Client
A complete Git client is a pretty amazing thing.
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :bind ("C-x g" . magit-status))
#+end_src
We'll also grab a few bonus features as well:
#+begin_src emacs-lisp
  (use-package magit-todos
    :ensure t
    :after magit
    :diminish
    :init
    (magit-todos-mode 1))
#+end_src
**** ~forge~: A Git Forge Client
Like ~magit~ but for GitHub. Invaluable.
#+begin_src emacs-lisp
  ;; needed for github secret
  (setq auth-sources '("~/.authinfo"))

  (use-package forge
    :ensure t
    :after magit)
#+end_src
**** ~igist~: GitHub Gist Client
It's useful for quickly sharing code with someone, and has a nice transient interface. This is probably the best solution for collaborating on a document, which Emacs still can't really do yet.
#+begin_src emacs-lisp
  (use-package igist
    :ensure t)
#+end_src
**** ~multiple-cursors~: Edit (At Scale)
This is a crazy package. You can basically select everything you want in one fell swoop, and it makes it extremely easy to do mass editing. Way, way better than the VSCode implementation of this feature (you don't even need to select the same feature, Emacs does it for you). 
#+begin_src emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :bind (("C-S-c C-S-c" . mc/edit-lines)
	   ("C->" . mc/mark-next-like-this)
	   ("C-<" . mc/mark-previous-like-this)
	   ("C-c C-<" . mc/mark-all-like-this)))
#+end_src
**** ~expand-region~: Semantic Selection
This is a lot faster than using the standard text commands. This one selects by semantic regions, so it's quite a lot faster.
#+begin_src emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("C-=" . er/expand-region))
#+end_src
**** ~docker~: Docker Client
Docker is a terrible piece of software that should never be used. But yet.
#+begin_src emacs-lisp
  (use-package docker
    :ensure t)
#+end_src
**** ~git-timemachine~: Git Time Travel
Does exactly what it says. Has some weird default settings.
#+begin_src emacs-lisp
  (use-package git-timemachine
    :ensure t)
#+end_src
**** ~git-link~: View Online Git
This is nice because it plays well with ~git-timemachine~, so it really does work on any given buffer for Git. 
#+begin_src emacs-lisp
  (use-package git-link
    :ensure t)
#+end_src
**** ~smeargle~: Age At A Glance
When activated, you can see the age of a given line (in Git-controlled buffers).
#+begin_src emacs-lisp
  (use-package smeargle
    :ensure t)
#+end_src
**** ~diff-hl~: Changes in Fringes
Shows what has changed between Git commits. This doesn't work without a graphical frame and it doesn't work on non-version controlled files. It's in the right fringe because nothing useful ever happens there and that's where we want all that good info anyways.
#+begin_src emacs-lisp
  (use-package diff-hl
    :ensure t
    :if window-system
    :hook (after-init . global-diff-hl-mode)
    :diminish global-diff-hl-mode
    :custom
    (diff-hl-disable-on-remote t)
    (diff-hl-margin-symbols-alist
     '((insert . "+")
       (delete . "-")
       (change . "*")
       (unknown . "?")
       (ignored . "i")))
    :init
    (setq-default diff-hl-side 'right))

#+end_src
**** ~treesit-fold~: Folding in Fringes
So shockingly Emacs doesn't ship with code folding outside of Org. This fixes this.
#+begin_src emacs-lisp
  (use-package treesit-fold
    :ensure t
    :diminish global-treesit-fold-indicators-mode
    :init
    (global-treesit-fold-indicators-mode))
#+end_src
**** ~flycheck~: Frontend to ~lsp-mode~
In modern Emacs, the LSP server handles all the actual work of linting, fixing, and correcting our code. We hand off the actually challenging tasks to it, but still need some nice features to go through what it says it's doing. So we add this in.
#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t)
#+end_src
**** ~lsp-mode~: Language Server Protocol Support
We are installing as few ~flycheck~ modes as possible, this is basically our only backend. 
#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :init
    (setq lsp-keymap-prefix "C-c l"
	  ;; override the completion with corfu
	  lsp-completion-provider :none
	  lsp-completion-enable t
	  ;; turn off all this visual junk
	  lsp-headerline-breadcrumb-enable nil
	  lsp-ui-sideline-enable nil ;; TODO: maybe change this?
	  lsp-auto-guess-root t
	  lsp-tex-server 'texlab)
    (defun personal/lsp-mode-setup-completion ()
      (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
	    '(orderless)))
    (add-hook 'lsp-completion-mode-hook #'personal/lsp-mode-setup-completion)
    :hook ((python-mode . lsp)
	   (java-mode . lsp)
	   (LaTeX-mode . lsp)
	   (latex-mode . lsp)
	   (tex-mode . lsp)
	   (bibtex-mode . lsp)
	   (yatex-mode . lsp)
	   (lsp-mode . lsp-enable-which-key-integration)))

  (use-package lsp-ui
    :ensure t
    :after lsp-mode
    :config
    (setq lsp-ui-doc-enable t
	  lsp-ui-doc-delay 0.5
	  lsp-ui-doc-show-with-cursor t
	  lsp-ui-doc-position 'at-point))

  ;; TODO: this messes up tree-sitter folding
  (use-package dap-mode
    :ensure t
    :disabled t
    :after lsp-mode
    :config
    (dap-auto-configure-mode))  
#+end_src
**** ~ellama~: AI Programming
AI peer programming is cool sometimes. Try to use this minimally (it makes you dumber), and DeepSeek's model is Good Enough for the vast majority of my simple needs. So you'll need to pull it using ~ollama~ obviously.
#+begin_src emacs-lisp
  (use-package ellama
    :ensure t
    :diminish 
    :bind ("C-c e" . ellama)
    ;; send last message in chat buffer with C-c C-c
    :hook (org-ctrl-c-ctrl-c-final . ellama-chat-send-last-message)
    :init (setopt ellama-auto-scroll t)
    :config
    ;; show ellama context in header line in all buffers
    ;;(ellama-context-header-line-global-mode +1)
    ;; show ellama session id in header line in all buffers
    ;;(ellama-session-header-line-global-mode +1)
    )
#+end_src
**** Language: LaTeX
LaTeX is very cool and Emacs is really, really good at this mode nowadays. Let's set up a nicer environment first:
#+begin_src emacs-lisp
  ;; the all purpose LaTeX environment
  (use-package auctex
    :ensure t
    ;; the weird name diffs it from the default installed one
    :hook ((LaTeX-mode . outline-minor-mode) ;; tab through our document like Org
	   (LaTeX-mode . prettify-symbols-mode) ;; math looks way nicer
	   (LaTeX-mode . LaTeX-math-mode) ;; make math nicer
	   (LaTeX-mode . visual-line-mode)
	   (LaTeX-mode . TeX-PDF-mode))
    :config
    (setq-default TeX-auto-save t
		  TeX-parse-self t
		  TeX-save-query nil
		  TeX-preview-default nil
		  TeX-source-correlate-method 'synctex
		  TeX-source-correlate-start-server t
		  TeX-view-program-selection '((output-pdf "PDF Tools"))
		  TeX-view-program-list '(("PDF Tools" TeX-pdf-tools-sync-view)))
    (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer))

  ;; use TAB to jump around the mode really, really fast
  (use-package cdlatex
    :ensure t
    :after auctex
    :diminish 
    :hook (LaTeX-mode . turn-on-cdlatex))
#+end_src
Cool. Now let's set up automatic previews: 
#+begin_src emacs-lisp
  (defun personal/latex-auto-compile ()
    (when (eq major-mode 'LaTeX-mode)
      (TeX-save-document (TeX-master-file))
      (TeX-command "LaTeX" 'TeX-master-file -1)))

  (add-hook 'after-save-hook #'personal/latex-auto-compile)
#+end_src
And we also want to grab some enhancements for our LSP server:
#+begin_src emacs-lisp
  (use-package lsp-latex
    :ensure t
    :after lsp-mode)
#+end_src
**** Language: MATLAB
To be honest, I think I can make this do more, such as having MATLAB as a language server. How exactly is a bit difficult. This code seems to maybe have some answers? https://github.com/karthink/.emacs.d/blob/master/init.el#L1660

TODO: improve this
#+begin_src emacs-lisp
  (use-package matlab-mode
    :ensure t)
#+end_src
**** Language: Python
The actual mode is bundled with Emacs, but the default interpreter is trash. Let's use the better one:
#+begin_src emacs-lisp
  (when (executable-find "ipython")
    (setq python-shell-interpreter "ipython"
	  python-shell-interpreter-args "-i --simple-prompt"))
#+end_src 
I use Anaconda, so unfortunately we have to do this:
#+begin_src emacs-lisp
  (use-package conda
    :ensure t
    :init
    (setq conda-anaconda-home "/opt/anaconda3/"
	  conda-env-autoactivate-mode t)
    :config
    (conda-env-activate "base"))
#+end_src
~lsp-mode~ crashes and burns with ~pylsp~ when we use Anaconda, so:
#+begin_src emacs-lisp
  (use-package lsp-pyright
    :ensure t
    :after lsp-mode
    :config
    ;; fix lsp mode
    (setq lsp-pyright-python-executable-cmd "/opt/anaconda3/bin/python"
	  lsp-disabled-clients '(pylsp))
    ;; I know better than the debugger in many cases
    (setq lsp-pyright-diagnostic-mode "openFilesOnly"
	  lsp-pyright-disable-language-services nil
	  lsp-pyright-disable-organize-imports nil
	  lsp-pyright-type-checking-mode "basic")
    (add-hook 'python-mode-hook #'(lambda () (require 'lsp-pyright) (lsp))))
#+end_src
This fixes syntax on save:
#+begin_src emacs-lisp
  (use-package blacken
    :ensure t
    :ensure-system-package black
    :diminish
    :hook ((python-mode . blacken-mode)))
#+end_src
And this lets us edit PIP standards:
#+begin_src emacs-lisp
  (use-package pip-requirements
    :ensure t)
#+end_src
**** Language: Go
The mode doesn't really come with Emacs:
#+begin_src emacs-lisp
  (use-package go-mode
    :ensure t
    :config
    (add-hook 'before-save-hook 'gofmt-before-save)
    :init
    ;; fix annoying issues with GOPATH
    (setenv "GOPATH" (concat (getenv "HOME") "/.go")))
#+end_src
**** Language: Markdown
No mode for it by default:
#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t)
#+end_src
Also, with some cool magic we can use ~eww~ to preview what it'll look like if we're writing a GitHub ~README.md~, using this package:
#+begin_src emacs-lisp
  (use-package gh-md
    :ensure t)
#+end_src
**** Language: Rust
The mode doesn't really come with Emacs:
TODO: Fix this
#+begin_src emacs-lisp
  (use-package rust-mode
    :ensure t)
#+end_src
**** Language: Clojure
The mode doesn't really come with Emacs:
TODO: Fix this
#+begin_src emacs-lisp
  (use-package cider
    :ensure t)
#+end_src
**** Language: Nix
This mode brings a lot to the table, but almost never actually need all it brings.
#+begin_src emacs-lisp
  (use-package nix-mode
    :ensure t
    :mode "\\.nix\\'")
#+end_src
**** Language: Java
This one ships with Emacs! We can make it smarter by having it chat with the LSP though:
#+begin_src emacs-lisp
  (use-package lsp-java
    :ensure t
    :config
    (setq lsp-java-server-install-dir "~/.emacs.d/eclipse.jdt.ls/server/"
	  lsp-java-java-path "/opt/homebrew/opt/openjdk/bin/java"))
#+end_src
*** Packages: Misc Modes
These are all the things that are needed for occasional, one-off editing and rarely matter all that much. They're kept around because on that blue moon where I actually need to edit one of these obscure types in Emacs, it's there.
**** Mode: Cask
For developing Elisp, not the one used in macOS Homebrew.
#+begin_src emacs-lisp
  (use-package cask-mode
    :ensure t)
#+end_src emacs-lisp
**** Mode: Lua
#+begin_src emacs-lisp
  (use-package lua-mode
    :ensure t
    :mode "\\.lua\\'")
#+end_src emacs-lisp
**** Mode: CMake
#+begin_src emacs-lisp
  (use-package cmake-mode
    :ensure t)
#+end_src
**** Mode: Apache Config
#+begin_src emacs-lisp
  (use-package apache-mode
    :ensure t)
#+end_src
**** Mode: BASIC
Hopefully this will never, ever be needed.
#+begin_src emacs-lisp
  (use-package basic-mode
    :ensure t
    :mode "\\.bas\\'")
#+end_src
**** Mode: AppleScript
AppleScript is not great.
#+begin_src emacs-lisp
  (use-package applescript-mode
    :ensure t
    :init
    (add-to-list 'auto-mode-alist '("\\.applescript$" . applescript-mode)))
#+end_src
**** Mode: Crontab
#+begin_src emacs-lisp
  (use-package crontab-mode
    :ensure t
    :mode "\\.crontab\\'")
#+end_src
**** Mode: Vimrc
#+begin_src emacs-lisp
  (use-package vimrc-mode
    :ensure t
    :mode "\\.vimrc\\.virc\\'")
#+end_src
**** Mode: Systemd Config
#+begin_src emacs-lisp
  (use-package systemd
    :ensure t
    :mode "\\.unit\\.service\\'")

  (use-package journalctl-mode
    :ensure t)
#+end_src
**** Mode: Git Config
#+begin_src emacs-lisp
  (use-package git-modes
    :ensure t
    :mode "\\.gitconfig\\'")
#+end_src
**** Mode: DHall
#+begin_src emacs-lisp
  (use-package dhall-mode
    :ensure t
    :mode "\\.dhall\\'")
#+end_src
**** Mode: CSV Files
#+begin_src emacs-lisp
  (use-package csv-mode
    :ensure t
    :mode "\\.[Cc][Ss][Vv]\\'"
    :config
    (setq csv-separators '("," ";" "|" " ")))
#+end_src
**** Mode: JSON Files
#+begin_src emacs-lisp
  (use-package json-mode
    :ensure t
    :mode "\\.json\\'")
#+end_src
**** Mode: YAML Files & Ansible
So we can do this to get the basic modes:
#+begin_src emacs-lisp
  (use-package yaml-mode
    :ensure t
    :mode "\\.yml\\.erb\\'")

  (use-package ansible
    :ensure t
    :init
    (add-hook 'yaml-mode-hook '(lambda () (ansible-mode 1))))
#+end_src
But there's a polymode so we can write Jinja2 inside of Ansible:
#+begin_src emacs-lisp
  (use-package poly-ansible
    :ensure t)
#+end_src
**** Mode: Unix Log
#+begin_src emacs-lisp
  (use-package logview
    :ensure t)
#+end_src
**** Mode: Jinja2
#+begin_src emacs-lisp
  (use-package jinja2-mode
    :ensure t
    :mode "\\.j2\\'")
#+end_src
**** Mode: phpBB
#+begin_src emacs-lisp
  (use-package bbcode-mode
    :ensure t)
#+end_src
**** Mode: Standard ENV File
#+begin_src emacs-lisp
  (use-package dotenv-mode
    :ensure t
    :mode "\\.env\\'")
#+end_src
**** Mode: Standard INI File
#+begin_src emacs-lisp
  (use-package ini-mode
    :ensure t
    :mode "\\.ini\\'")
#+end_src
**** Mode: AutoHotKey
#+begin_src emacs-lisp
  (use-package ahk-mode
    :ensure t
    :mode "\\.ahk\\'")
#+end_src
**** Mode: Dockerfile
#+begin_src emacs-lisp
  (use-package dockerfile-mode
    :ensure t)
#+end_src
**** Mode: AppArmor Config
#+begin_src emacs-lisp
  (use-package apparmor-mode
    :ensure t
    :init
    (require 'apparmor-mode))
#+end_src
**** Mode: FVWM Config
#+begin_src emacs-lisp
  (use-package fvwm-mode
    :ensure t
    :mode "\\.fvwm\\'")
#+end_src
**** Mode: tmux Config
#+begin_src emacs-lisp
  (use-package tmux-mode
    :ensure t
    :mode "\\.tmux.conf\\'")
#+end_src
**** Mode: MediaWiki
#+begin_src emacs-lisp
  (use-package mediawiki
    :ensure t)
#+end_src
**** Mode: robots.txt
#+begin_src emacs-lisp
  (use-package robots-txt-mode
    :ensure t
    :init
    (add-to-list 'auto-mode-alist '("robots.txt" . robots-txt-mode)))
#+end_src
**** Mode: PowerShell
#+begin_src emacs-lisp
  (use-package powershell
    :ensure t
    :mode "\\.ps1\\'")
#+end_src


